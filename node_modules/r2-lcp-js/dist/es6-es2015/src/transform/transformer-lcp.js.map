{"version":3,"file":"transformer-lcp.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as crypto from \"crypto\";\nimport * as debug_ from \"debug\";\nimport * as zlib from \"zlib\";\n\nimport { Encrypted } from \"@models/metadata-encrypted\";\nimport { IDecryptedBuffer, LCP } from \"@parser/epub/lcp\";\nimport { bufferToStream, streamToBufferPromise } from \"@r2-utils-js/_utils/stream/BufferUtils\";\nimport { RangeStream } from \"@r2-utils-js/_utils/stream/RangeStream\";\nimport { IStreamAndLength } from \"@r2-utils-js/_utils/zip/zip\";\n\n// import * as forge from \"node-forge\";\n// import { CounterPassThroughStream } from \"@r2-utils-js/_utils/stream/CounterPassThroughStream\";\n// import { Transform } from \"stream\";\n\nconst debug = debug_(\"r2:lcp#transform/transformer-lcp\");\n\nconst IS_DEV = (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\n\nconst AES_BLOCK_SIZE = 16;\n\n// let streamCounter = 0;\n\nconst readStream = async (s: NodeJS.ReadableStream, n: number): Promise<Buffer> => {\n    return new Promise<Buffer>((resolve, reject) => {\n        // s.pause();\n        const onReadable = () => {\n            // debug(\"readStream READABLE\");\n            const b = s.read(n);\n            s.removeListener(\"readable\", onReadable);\n            s.removeListener(\"error\", reject);\n            // s.resume();\n            resolve(b as Buffer);\n        };\n        s.on(\"readable\", onReadable);\n        s.on(\"error\", reject);\n        // s.on(\"end\", () => {\n        //     debug(\"readStream END\");\n        // });\n        // s.on(\"drain\", () => {\n        //     debug(\"readStream DRAIN\");\n        // });\n        // s.on(\"finish\", () => {\n        //     debug(\"readStream FINISH\");\n        // });\n    });\n};\n\nexport interface ICryptoInfo {\n    length: number;\n    padding: number;\n}\n\nexport function supports(\n    lcp: LCP,\n    _linkHref: string,\n    linkPropertiesEncrypted: Encrypted): boolean {\n\n    if (!lcp) {\n        return false;\n    }\n    if (!linkPropertiesEncrypted) {\n        return false;\n    }\n\n    if (!lcp.isReady()) {\n        debug(\"LCP not ready!\");\n        return false;\n    }\n\n    // TODO: check that the native lib supports the LCP profiles (basic or 1.0 or 2.x)\n    // getListOfSupportedProfileURIs()\n    const check =\n        linkPropertiesEncrypted.Algorithm === \"http://www.w3.org/2001/04/xmlenc#aes256-cbc\"\n        &&\n        (\n            (\n            linkPropertiesEncrypted.Scheme === \"http://readium.org/2014/01/lcp\"\n            &&\n            (\n            linkPropertiesEncrypted.Profile === \"http://readium.org/lcp/basic-profile\"\n            ||\n            linkPropertiesEncrypted.Profile === \"http://readium.org/lcp/profile-1.0\"\n            ||\n            (linkPropertiesEncrypted.Profile && /^http:\\/\\/readium\\.org\\/lcp\\/profile-2\\.[0-9]$/.test(linkPropertiesEncrypted.Profile))\n            )\n            )\n\n        ||\n\n            // the above test is an exact match for each information field in manifest.json,\n            // but this is very verbose and unnecessarily repetitive in \"Readium Web Pub Manifest\"\n            // so a future version of RWPM might not provide all these fields.\n            // Below is a simpler test based on the fact that:\n            // linkPropertiesEncrypted indicates that the resource is encrypted with AES-256-CBC,\n            // but it could be non-LCP obfuscation (e.g. IDPF or Adobe URIs) or a non-LCP DRM,\n            // so we must check the supported LCP profiles (basic or 1.0 or 2.x)\n            (\n            lcp.Encryption.Profile === \"http://readium.org/lcp/basic-profile\"\n            ||\n            lcp.Encryption.Profile === \"http://readium.org/lcp/profile-1.0\"\n            ||\n            (lcp.Encryption.Profile && /^http:\\/\\/readium\\.org\\/lcp\\/profile-2\\.[0-9]$/.test(lcp.Encryption.Profile))\n            )\n        )\n    ;\n\n    if (!check) {\n        // if (IS_DEV) {\n        //     debug(\"Incorrect resource LCP fields (obfuscated fonts?).\");\n        //     debug(linkPropertiesEncrypted.Scheme);\n        //     debug(linkPropertiesEncrypted.Profile);\n        //     debug(linkPropertiesEncrypted.Algorithm);\n        //     debug(lcp.Encryption.Profile);\n        // }\n        return false;\n    }\n\n    return true;\n}\n\nexport async function transformStream(\n    lcp: LCP,\n    linkHref: string,\n    linkPropertiesEncrypted: Encrypted,\n    stream: IStreamAndLength,\n    isPartialByteRangeRequest: boolean,\n    partialByteBegin: number,\n    partialByteEnd: number): Promise<IStreamAndLength> {\n\n    const isCompressionNone = linkPropertiesEncrypted.Compression === \"none\";\n    const isCompressionDeflate = linkPropertiesEncrypted.Compression === \"deflate\";\n\n    let plainTextSize = -1;\n\n    let nativelyDecryptedStream: NodeJS.ReadableStream | undefined;\n    let nativelyInflated = false;\n    if (lcp.isNativeNodePlugin()) {\n\n        if (IS_DEV) {\n            debug(\"LCP DECRYPT NATIVE: \" + linkHref);\n        }\n\n        let fullEncryptedBuffer: Buffer;\n        try {\n            fullEncryptedBuffer = await streamToBufferPromise(stream.stream);\n        } catch (err) {\n            debug(err);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"OUCH!\");\n        }\n\n        // debug(fullEncryptedBuffer.length);\n\n        // debug(fullEncryptedBuffer.slice(0, 32));\n\n        // debug(fullEncryptedBuffer.slice(fullEncryptedBuffer.length - 32));\n\n        let res: IDecryptedBuffer;\n        try {\n            res = await lcp.decrypt(fullEncryptedBuffer, linkHref, isCompressionDeflate);\n        } catch (err) {\n            debug(err);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"OUCH!\");\n        }\n\n        const nativelyDecryptedBuffer = res.buffer;\n        nativelyInflated = res.inflated;\n\n        // debug(nativelyDecryptedBuffer.length);\n\n        plainTextSize = nativelyDecryptedBuffer.length;\n        linkPropertiesEncrypted.DecryptedLengthBeforeInflate = plainTextSize;\n\n        if (!nativelyInflated && // necessary, even if isCompressionNone! (LCP inflation byte variance)\n            linkPropertiesEncrypted.OriginalLength &&\n            isCompressionNone &&\n            linkPropertiesEncrypted.OriginalLength !== plainTextSize) {\n\n            debug(\"############### LCP transformStream() LENGTH NOT MATCH linkPropertiesEncrypted.OriginalLength !== plainTextSize: \" +\n                `${linkPropertiesEncrypted.OriginalLength} !== ${plainTextSize}`);\n        }\n\n        nativelyDecryptedStream = bufferToStream(nativelyDecryptedBuffer);\n    } else {\n        let cryptoInfo: ICryptoInfo | undefined;\n        let cypherBlockPadding = -1;\n        if (linkPropertiesEncrypted.DecryptedLengthBeforeInflate > 0) {\n            plainTextSize = linkPropertiesEncrypted.DecryptedLengthBeforeInflate;\n            cypherBlockPadding = linkPropertiesEncrypted.CypherBlockPadding;\n        } else {\n            // const timeBegin = process.hrtime();\n            try {\n                cryptoInfo = await getDecryptedSizeStream(lcp, stream);\n            } catch (err) {\n                debug(err);\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                return Promise.reject(err);\n            }\n            plainTextSize = cryptoInfo.length;\n            cypherBlockPadding = cryptoInfo.padding;\n\n            // length cached to avoid resetting the stream to zero-position\n            linkPropertiesEncrypted.DecryptedLengthBeforeInflate = plainTextSize;\n            linkPropertiesEncrypted.CypherBlockPadding = cypherBlockPadding;\n\n            try {\n                stream = await stream.reset();\n            } catch (err) {\n                debug(err);\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                return Promise.reject(err);\n            }\n\n            // const timeElapsed = process.hrtime(timeBegin);\n            // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\n            //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\n\n            // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n\n            if (linkPropertiesEncrypted.OriginalLength &&\n                isCompressionNone &&\n                linkPropertiesEncrypted.OriginalLength !== plainTextSize) {\n\n                debug(\"############### LCP transformStream() LENGTH NOT MATCH linkPropertiesEncrypted.OriginalLength !== plainTextSize: \" +\n                    `${linkPropertiesEncrypted.OriginalLength} !== ${plainTextSize}`);\n            }\n        }\n    }\n\n    let destStream: NodeJS.ReadableStream;\n    if (nativelyDecryptedStream) {\n        destStream = nativelyDecryptedStream;\n    } else {\n        // const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n        let rawDecryptStream: NodeJS.ReadableStream | undefined;\n\n        let ivBuffer: Buffer | undefined;\n        if (linkPropertiesEncrypted.CypherBlockIV) {\n            ivBuffer = Buffer.from(linkPropertiesEncrypted.CypherBlockIV, \"binary\");\n\n            const cypherRangeStream = new RangeStream(AES_BLOCK_SIZE, stream.length - 1, stream.length);\n            stream.stream.pipe(cypherRangeStream);\n            rawDecryptStream = cypherRangeStream;\n        } else {\n            // const ivRangeStream = new RangeStream(0, AES_BLOCK_SIZE - 1, stream.length);\n            // stream.stream.pipe(ivRangeStream);\n            // try {\n            //     ivBuffer = await streamToBufferPromise(ivRangeStream);\n            // } catch (err) {\n            //     debug(err);\n            //     // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            //     return Promise.reject(\"OUCH!\");\n            // }\n            // try {\n            //     stream = await stream.reset();\n            // } catch (err) {\n            //     debug(err);\n            //     // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            //     return Promise.reject(err);\n            // }\n\n            // debug(\"D1\");\n            // debug(ivBuffer.length);\n            // debug(ivBuffer.toString(\"hex\"));\n\n            // ivBuffer = stream.stream.read(AES_BLOCK_SIZE) as Buffer;\n\n            try {\n                ivBuffer = await readStream(stream.stream, AES_BLOCK_SIZE);\n            } catch (err) {\n                debug(err);\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                return Promise.reject(err);\n            }\n\n            // debug(\"D2\");\n            // debug(ivBuffer.length);\n            // debug(ivBuffer.toString(\"hex\"));\n            // b06ca4cec8831eb158f1a317503f5101\n            // === asharedculture_soundtrack.mp3\n            //\n            // 07e6870e5d708f39e98316b5c0a574c5\n            // === shared-culture.mp4\n\n            linkPropertiesEncrypted.CypherBlockIV = ivBuffer.toString(\"binary\");\n\n            stream.stream.resume();\n            rawDecryptStream = stream.stream;\n        }\n        // debug(\"IV: \" + forge.util.bytesToHex(ivBuffer));\n\n        // debug(forge.util.bytesToHex(contentKey as string));\n\n        // https://github.com/nodejs/node/blob/master/lib/crypto.js#L259\n        const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\n            // Note: assumes lcp.ContentKey has been set (can be undefined)\n            // (this is only for testing the pure JS implementation anyway)\n            lcp.ContentKey as Buffer, // Buffer.from(contentKey as string, \"binary\"),\n            ivBuffer);\n        decryptStream.setAutoPadding(false);\n        rawDecryptStream.pipe(decryptStream);\n\n        destStream = decryptStream;\n\n        if (linkPropertiesEncrypted.CypherBlockPadding) {\n            // debugx(\"cryptoInfo.padding: \" + cypherBlockPadding);\n            const cypherUnpaddedStream = new RangeStream(0, plainTextSize - 1, plainTextSize);\n            destStream.pipe(cypherUnpaddedStream);\n            destStream = cypherUnpaddedStream;\n        }\n\n        // const counterStream2 = new CounterPassThroughStream(++streamCounter);\n        // destStream.pipe(counterStream2)\n        //     .on(\"progress\", function f() {\n        //         // debug(\"Crypto PROGRESS: \" +\n        //         //     (this as CounterPassThroughStream).id +\n        //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n        //     })\n        //     .on(\"end\", function f() {\n        //         debug(\"Crypto END: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"close\", function f() {\n        //         debug(\"Crypto CLOSE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .once(\"finish\", function f() {\n        //         debug(\"Crypto FINISH: \" +\n        //             (this as CounterPassThroughStream).id +\n        //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n\n        //         if (plainTextSize !==\n        //             (this as CounterPassThroughStream).bytesReceived) {\n\n        //             debug(`############### ` +\n        //                 `LCP Crypto LENGTH NOT MATCH ` +\n        //                 `plainTextSize !== bytesReceived:` +\n        //                 `${plainTextSize} !== ` +\n        //                 `${(this as CounterPassThroughStream).bytesReceived}`);\n        //         }\n        //     })\n        //     .on(\"error\", function f() {\n        //         debug(\"CounterPassThroughStream ERROR: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"pipe\", function f() {\n        //         debug(\"CounterPassThroughStream PIPE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"unpipe\", function f() {\n        //         debug(\"CounterPassThroughStream UNPIPE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"drain\", function f() {\n        //         // debug(\"CounterPassThroughStream DRAIN: \" +\n        //         //     (this as CounterPassThroughStream).id);\n        //     });\n        // destStream = counterStream2;\n    }\n\n    if (!nativelyInflated && isCompressionDeflate) {\n\n        // https://github.com/nodejs/node/blob/master/lib/zlib.js\n        const inflateStream = zlib.createInflateRaw();\n        destStream.pipe(inflateStream);\n        destStream = inflateStream;\n\n        if (!linkPropertiesEncrypted.OriginalLength) {\n            debug(\"############### RESOURCE ENCRYPTED OVER DEFLATE, BUT NO OriginalLength!\");\n\n            let fullDeflatedBuffer: Buffer;\n            try {\n                fullDeflatedBuffer = await streamToBufferPromise(destStream);\n                linkPropertiesEncrypted.OriginalLength = fullDeflatedBuffer.length;\n                destStream = bufferToStream(fullDeflatedBuffer);\n            } catch (err) {\n                debug(err);\n            }\n        }\n\n        // const counterStream = new CounterPassThroughStream(++streamCounter);\n        // inflateStream.pipe(counterStream)\n        //     .on(\"progress\", function f() {\n        //         // debug(\"CounterPassThroughStream PROGRESS: \" +\n        //         //     (this as CounterPassThroughStream).id +\n        //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n        //     })\n        //     .on(\"end\", function f() {\n        //         debug(\"CounterPassThroughStream END: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"close\", function f() {\n        //         debug(\"CounterPassThroughStream CLOSE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .once(\"finish\", function f() {\n        //         debug(\"CounterPassThroughStream FINISH: \" +\n        //             (this as CounterPassThroughStream).id +\n        //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n\n        //         if (linkPropertiesEncrypted.OriginalLength &&\n        //             linkPropertiesEncrypted.OriginalLength !==\n        //             (this as CounterPassThroughStream).bytesReceived) {\n\n        //             debug(`############### ` +\n        //                 `LCP zlib.createInflateRaw LENGTH NOT MATCH ` +\n        //                 `linkPropertiesEncrypted.OriginalLength !== bytesReceived:` +\n        //                 `${linkPropertiesEncrypted.OriginalLength} !== ` +\n        //                 `${(this as CounterPassThroughStream).bytesReceived}`);\n        //         }\n        //     })\n        //     .on(\"error\", function f() {\n        //         debug(\"CounterPassThroughStream ERROR: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"pipe\", function f() {\n        //         debug(\"CounterPassThroughStream PIPE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"unpipe\", function f() {\n        //         debug(\"CounterPassThroughStream UNPIPE: \" +\n        //             (this as CounterPassThroughStream).id);\n        //     })\n        //     .on(\"drain\", function f() {\n        //         // debug(\"CounterPassThroughStream DRAIN: \" +\n        //         //     (this as CounterPassThroughStream).id);\n        //     });\n        // destStream = counterStream;\n    }\n\n    if (partialByteBegin < 0) {\n        partialByteBegin = 0;\n    }\n\n    if (partialByteEnd < 0) {\n        partialByteEnd = plainTextSize - 1;\n        if (linkPropertiesEncrypted.OriginalLength) {\n            partialByteEnd = linkPropertiesEncrypted.OriginalLength - 1;\n        }\n    }\n\n    const l = (!nativelyInflated && linkPropertiesEncrypted.OriginalLength) ?\n        linkPropertiesEncrypted.OriginalLength : plainTextSize;\n\n    if (isPartialByteRangeRequest) {\n        const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, l);\n        destStream.pipe(rangeStream);\n        destStream = rangeStream;\n        // l = partialByteLength;\n    }\n\n    const sal: IStreamAndLength = {\n        length: l,\n        reset: async () => {\n\n            let resetedStream: IStreamAndLength;\n            try {\n                resetedStream = await stream.reset();\n            } catch (err) {\n                debug(err);\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                return Promise.reject(err);\n            }\n\n            return transformStream(\n                lcp, linkHref, linkPropertiesEncrypted,\n                resetedStream,\n                isPartialByteRangeRequest,\n                partialByteBegin, partialByteEnd);\n        },\n        stream: destStream,\n    };\n    return Promise.resolve(sal);\n}\n\nexport async function getDecryptedSizeStream(\n    lcp: LCP,\n    stream: IStreamAndLength): Promise<ICryptoInfo> {\n\n    return new Promise<ICryptoInfo>(async (resolve, reject) => {\n\n        // debug(\"LCP getDecryptedSizeStream() stream.length: \" + stream.length);\n\n        // debug(\"LCP getDecryptedSizeStream() AES_BLOCK_SIZE: \" + AES_BLOCK_SIZE);\n\n        // CipherText = IV + PlainText + BLOCK - (PlainText MOD BLOCK)\n        // overflow: (PlainText MOD BLOCK) === PlainText - (floor(PlainText / BLOCK) * BLOCK)\n        // thus: CipherText = IV + BLOCK * (floor(PlainText / BLOCK) + 1)\n\n        // IV = AES_BLOCK_SIZE (first block in cyphertext)\n        // + at least one block\n        // (last one in cyphertext is either full 16-bytes random W3C padding\n        // in case plaintext is exactly multiple of block size,\n        // or partial cypher + padding)\n        const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n        if (stream.length < TWO_AES_BLOCK_SIZE) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(\"crypto err\");\n            return;\n        }\n        const readPos = stream.length - TWO_AES_BLOCK_SIZE;\n\n        const cypherRangeStream = new RangeStream(readPos, readPos + TWO_AES_BLOCK_SIZE - 1, stream.length);\n        stream.stream.pipe(cypherRangeStream);\n\n        // let buff: Buffer;\n        // try {\n        //     buff = await streamToBufferPromise(cypherRangeStream);\n        // } catch (err) {\n        //     debug(err);\n        //     // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //     reject(\"crypto err\");\n        //     return;\n        // }\n\n        // // debug(\"LCP getDecryptedSizeStream() buff.length: \" + buff.length);\n\n        // // // debug(buff.toString(\"hex\"));\n        // // for (let i = 0; i < buff.length; i++) {\n        // //     const b = buff[i];\n        // //     if (i === AES_BLOCK_SIZE) {\n        // //         debug(\"____\");\n        // //     }\n        // //     debug(b);\n        // // }\n\n        // resolve(this.getDecryptedSizeBuffer_(stream.length, buff));\n\n        const decrypteds: Buffer[] = [];\n        const handle = (ivBuffer: Buffer, encrypted: Buffer) => {\n\n            const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\n                // Note: assumes lcp.ContentKey has been set (can be undefined)\n                // (this is only for testing the pure JS implementation anyway)\n                lcp.ContentKey as Buffer, // Buffer.from(contentKey as string, \"binary\"),\n                ivBuffer);\n            decryptStream.setAutoPadding(false);\n\n            const buff1 = decryptStream.update(encrypted);\n            if (buff1) {\n                decrypteds.push(buff1);\n            }\n\n            const buff2 = decryptStream.final();\n            // debug(buff2.toString(\"hex\"));\n            if (buff2) {\n                decrypteds.push(buff2);\n            }\n\n            finish();\n        };\n\n        let finished = false;\n        const finish = () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            // cleanup();\n\n            const decrypted = Buffer.concat(decrypteds);\n            // debug(decrypted.toString(\"hex\"));\n            // debug(decrypted.length);\n            if (decrypted.length !== AES_BLOCK_SIZE) {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(\"decrypted.length !== AES_BLOCK_SIZE\");\n                return;\n            }\n\n            const nPaddingBytes = decrypted[AES_BLOCK_SIZE - 1]; // decrypted.length = 1\n            // debug(nPaddingBytes);\n\n            const size = stream.length - AES_BLOCK_SIZE - nPaddingBytes;\n\n            const res: ICryptoInfo = {\n                length: size,\n                padding: nPaddingBytes,\n            };\n            resolve(res);\n        };\n\n        try {\n            const buf = await readStream(cypherRangeStream, TWO_AES_BLOCK_SIZE);\n            if (!buf) {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(\"!buf (end?)\");\n                return;\n            }\n            if (buf.length !== TWO_AES_BLOCK_SIZE) {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(\"buf.length !== TWO_AES_BLOCK_SIZE\");\n                return;\n            }\n            handle(buf.slice(0, AES_BLOCK_SIZE), buf.slice(AES_BLOCK_SIZE));\n        } catch (err) {\n            debug(err);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(err);\n            return;\n        }\n\n        // const cleanup = () => {\n        //     cypherRangeStream.removeListener(\"readable\", handleReadable);\n        //     cypherRangeStream.removeListener(\"error\", handleError);\n        //     cypherRangeStream.removeListener(\"end\", handleEnd);\n        // };\n\n        // const handleReadable = () => {\n        //     // debug(\"readable\");\n\n        //     const ivBuffer = cypherRangeStream.read(AES_BLOCK_SIZE);\n        //     if (!ivBuffer) {\n        //         // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //         reject(\"!ivBuffer (end?)\");\n        //         return;\n        //     }\n        //     if (ivBuffer.length !== AES_BLOCK_SIZE) {\n        //         // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //         reject(\"ivBuffer.length !== AES_BLOCK_SIZE\");\n        //         return;\n        //     }\n\n        //     const encrypted = cypherRangeStream.read(AES_BLOCK_SIZE);\n        //     if (!encrypted) {\n        //         // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //         reject(\"!encrypted (end?)\");\n        //         return;\n        //     }\n        //     if (encrypted.length !== AES_BLOCK_SIZE) {\n        //         // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //         reject(\"encrypted.length !== AES_BLOCK_SIZE\");\n        //         return;\n        //     }\n\n        //     handle(ivBuffer, encrypted);\n        // };\n        // cypherRangeStream.on(\"readable\", handleReadable);\n\n        // // // With NodeJS v8, this event is raised. Not with NodeJS 10+\n        // // const handleEnd = () => {\n        // //     finish();\n        // // };\n        // // cypherRangeStream.on(\"end\", handleEnd);\n\n        // const handleError = () => {\n        //     cleanup();\n        //     // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        //     reject();\n        // };\n        // cypherRangeStream.on(\"error\", handleError);\n    });\n}\n"]}