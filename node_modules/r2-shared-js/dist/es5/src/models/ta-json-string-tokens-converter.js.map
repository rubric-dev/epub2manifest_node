{"version":3,"file":"ta-json-string-tokens-converter.js","sourceRoot":"","sources":["../../../../src/models/ta-json-string-tokens-converter.ts"],"names":[],"mappings":";;;AAiBO,IAAM,+BAA+B,GAAG,UAAC,GAAW;IACvD,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC;QACjB,GAAG,CAAC,UAAC,KAAK,IAAK,OAAA,KAAK,CAAC,IAAI,EAAE,EAAZ,CAAY,CAAC;QAC5B,MAAM,CAAC,UAAC,KAAK,IAAK,OAAA,KAAK,CAAC,MAAM,EAAZ,CAAY,CAAC;QAC/B,MAAM,CAAC,UAAC,EAAE,EAAE,EAAE,IAAK,OAAA,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,EAApC,CAAoC,EAAE,EAAc,CAAC;QACxE,MAAM,CAAC,UAAC,GAAG,IAAK,OAAA,GAAG,CAAC,MAAM,EAAV,CAAU,CAAC,CAAC;AACpC,CAAC,CAAC;AANW,QAAA,+BAA+B,mCAM1C;AACK,IAAM,gCAAgC,GAAG,UAAC,qBAA+B;IAC5E,OAAO,qBAAqB,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,IAAA,uCAA+B,EAAC,GAAG,CAAC,EAApC,CAAoC,CAAC,CAAC;AACpF,CAAC,CAAC;AAFW,QAAA,gCAAgC,oCAE3C;AACK,IAAM,8BAA8B,GAAG,UAAC,qBAAmC;IAC9E,OAAO,qBAAqB,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,EAAb,CAAa,CAAC,CAAC;AAC7D,CAAC,CAAC;AAFW,QAAA,8BAA8B,kCAEzC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\n// tslint:disable-next-line: max-line-length\n// node -e 'const parse = (AccessModeSufficient) => console.log(JSON.stringify(AccessModeSufficient.map((ams) => ams.split(\",\").map((token) => token.trim()).filter((token) => token.length).reduce((pv, cv) => pv.includes(cv) ? pv : pv.concat(cv), [])).filter((arr) => arr.length))); parse([]); parse([\"\"]); parse([\"visual,textual\"]); parse([\"  visual   , textual  \"]); parse([\"  visual   , textual , visual \"]); parse([\"  visual   , textual , visual \", \"auditory, auditory\"]); parse([\"\", \"  visual   , textual ,, visual \", \"auditory, auditory,,\"]);'\n// ====>\n// []\n// []\n// [[\"visual\",\"textual\"]]\n// [[\"visual\",\"textual\"]]\n// [[\"visual\",\"textual\"]]\n// [[\"visual\",\"textual\"],[\"auditory\"]]\n// [[\"visual\",\"textual\"],[\"auditory\"]]\nexport const DelinearizeAccessModeSufficient = (ams: string): string[] => {\n    return ams.split(\",\").\n        map((token) => token.trim()).\n        filter((token) => token.length).\n        reduce((pv, cv) => pv.includes(cv) ? pv : pv.concat(cv), [] as string[]).\n        filter((arr) => arr.length);\n};\nexport const DelinearizeAccessModeSufficients = (accessModeSufficients: string[]): (string[])[] => {\n    return accessModeSufficients.map((ams) => DelinearizeAccessModeSufficient(ams));\n};\nexport const LinearizeAccessModeSufficients = (accessModeSufficients: (string[])[]): string[] => {\n    return accessModeSufficients.map((ams) => ams.join(\",\"));\n};\n\n// import { IPropertyConverter, JsonValueArray } from \"ta-json-x\";\n//\n// export class JsonStringTokensConverter implements IPropertyConverter {\n//     public serialize(property: (string[])[]): JsonValueArray {\n//         return LinearizeAccessModeSufficients(property);\n//     }\n\n//     public deserialize(value: JsonValueArray): (string[])[] {\n//         return DelinearizeAccessModeSufficients(value as string[]);\n//     }\n\n//     public collapseArrayWithSingleItem(): boolean {\n//         return false;\n//     }\n// }\n"]}