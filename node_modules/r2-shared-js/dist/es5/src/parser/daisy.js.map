{"version":3,"file":"daisy.js","sourceRoot":"","sources":["../../../../src/parser/daisy.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { Metadata } from \"@models/metadata\";\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { isHTTP } from \"@r2-utils-js/_utils/http/UrlUtils\";\nimport { IZip } from \"@r2-utils-js/_utils/zip/zip\";\nimport { zipLoadPromise } from \"@r2-utils-js/_utils/zip/zipFactory\";\n\nimport { zipHasEntry } from \"../_utils/zipHasEntry\";\nimport { convertNccToOpfAndNcx } from \"./daisy-convert-ncc-to-opf-ncx\";\nimport {\n    addIdentifier, addLanguage, addMediaOverlaySMIL, addOtherMetadata, addTitle,\n    fillPublicationDate, fillSpineAndResource, fillSubject, fillTOC, findContributorInMeta, getNcx,\n    getOpf, lazyLoadMediaOverlays, setPublicationDirection, updateDurations,\n} from \"./epub-daisy-common\";\nimport { Rootfile } from \"./epub/container-rootfile\";\nimport { NCX } from \"./epub/ncx\";\nimport { OPF } from \"./epub/opf\";\nimport { Manifest } from \"./epub/opf-manifest\";\n\nconst debug = debug_(\"r2:shared#parser/daisy\");\n\nexport enum DaisyBookis {\n    LocalExploded = \"LocalExploded\",\n    LocalPacked = \"LocalPacked\",\n    RemoteExploded = \"RemoteExploded\",\n    RemotePacked = \"RemotePacked\",\n}\n\nexport async function isDaisyPublication(urlOrPath: string): Promise<DaisyBookis | undefined> {\n    let p = urlOrPath;\n    const http = isHTTP(urlOrPath);\n    if (http) {\n        const url = new URL(urlOrPath);\n        p = url.pathname;\n        return undefined; // remote DAISY not supported\n    } else if (/\\.daisy[23]?$/i.test(path.extname(path.basename(p)))) {\n\n        return DaisyBookis.LocalPacked;\n\n    } else if (fs.existsSync(path.join(urlOrPath, \"package.opf\")) ||\n        fs.existsSync(path.join(urlOrPath, \"Book.opf\")) ||\n        fs.existsSync(path.join(urlOrPath, \"ncc.html\")) ||\n        fs.existsSync(path.join(urlOrPath, \"speechgen.opf\"))\n    ) {\n        if (!fs.existsSync(path.join(urlOrPath, \"META-INF\", \"container.xml\"))) {\n\n            return DaisyBookis.LocalExploded;\n        }\n    } else {\n        let zip: IZip;\n        try {\n            zip = await zipLoadPromise(urlOrPath);\n        } catch (err) {\n            debug(err);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(err);\n        }\n\n        if (!await zipHasEntry(zip, \"META-INF/container.xml\", undefined)) {\n\n            // if (await zipHasEntry(zip, \"package.opf\", undefined) ||\n            //     await zipHasEntry(zip, \"Book.opf\", undefined) ||\n            //     await zipHasEntry(zip, \"speechgen.opf\", undefined)) {\n            //     return DaisyBookis.LocalPacked;\n            // }\n\n            const entries = await zip.getEntries();\n            const opfZipEntryPath = entries.find((entry) => {\n                // regexp fails?!\n                // return /[^/]+\\.opf$/i.test(entry);\n                // && entry.indexOf(\"/\") < 0 && entry.indexOf(\"\\\\\") < 0;\n                return /ncc\\.html$/i.test(entry) || /\\.opf$/i.test(entry);\n            });\n            if (!opfZipEntryPath) {\n                return undefined;\n            }\n\n            // TODO: check for <dc:Format>ANSI/NISO Z39.86-2005</dc:Format> ?\n            return DaisyBookis.LocalPacked;\n        }\n    }\n    return undefined;\n}\n\nexport async function DaisyParsePromise(filePath: string): Promise<Publication> {\n\n    // const isDaisy = await isDaisyPublication(filePath);\n\n    let zip: IZip;\n    try {\n        zip = await zipLoadPromise(filePath);\n    } catch (err) {\n        debug(err);\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(err);\n    }\n\n    if (!zip.hasEntries()) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(\"Daisy zip empty\");\n    }\n\n    const publication = new Publication();\n    publication.Context = [\"https://readium.org/webpub-manifest/context.jsonld\"];\n    publication.Metadata = new Metadata();\n    publication.Metadata.RDFType = \"http://schema.org/Book\";\n    // publication.Metadata.Modified = moment(Date.now()).toDate();\n\n    publication.AddToInternal(\"filename\", path.basename(filePath));\n\n    publication.AddToInternal(\"type\", \"daisy\");\n    publication.AddToInternal(\"zip\", zip);\n\n    // note: does not work in RemoteExploded\n    const entries = await zip.getEntries();\n\n    // const [valid, message] = isFileValid(entries);\n    // if (!valid) {\n    //     return Promise.reject(message || \"File validation failed.\");\n    // }\n\n    // generic \"text/xml\" content type\n    // manifest/item@media-type\n    let opfZipEntryPath = entries.find((entry) => {\n        // regexp fails?!\n        // return /[^/]+\\.opf$/i.test(entry);\n        // && entry.indexOf(\"/\") < 0 && entry.indexOf(\"\\\\\") < 0;\n        return /\\.opf$/i.test(entry);\n    });\n    let daisy2NccZipEntryPath: string | undefined;\n    if (!opfZipEntryPath) {\n        daisy2NccZipEntryPath = entries.find((entry) => {\n            return /ncc\\.html$/i.test(entry);\n        });\n        opfZipEntryPath = daisy2NccZipEntryPath;\n    }\n\n    if (!opfZipEntryPath) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(\"DAISY3 OPF package XML file or DAISY2 NCC cannot be found.\");\n    }\n\n    const rootfilePathDecoded = opfZipEntryPath; // || \"package.opf\";\n    if (!rootfilePathDecoded) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(\"?!rootfile.PathDecoded\");\n    }\n\n    let opf: OPF | undefined;\n    let ncx: NCX | undefined;\n    if (daisy2NccZipEntryPath) { // same as opfZipEntryPath\n        [opf, ncx] = await convertNccToOpfAndNcx(zip, rootfilePathDecoded, opfZipEntryPath);\n    } else {\n        opf = await getOpf(zip, rootfilePathDecoded, opfZipEntryPath);\n        if (opf.Manifest) {\n            let ncxManItem = opf.Manifest.find((manifestItem) => {\n                return manifestItem.MediaType === \"application/x-dtbncx+xml\";\n            });\n            if (!ncxManItem) {\n                ncxManItem = opf.Manifest.find((manifestItem) => {\n                    return manifestItem.MediaType === \"text/xml\" &&\n                        manifestItem.Href && /\\.ncx$/i.test(manifestItem.Href);\n                });\n            }\n            if (ncxManItem) {\n                ncx = await getNcx(ncxManItem, opf, zip);\n            }\n        }\n    }\n\n    addLanguage(publication, opf);\n\n    addTitle(publication, undefined, opf);\n\n    addIdentifier(publication, opf);\n\n    addOtherMetadata(publication, undefined, opf);\n\n    setPublicationDirection(publication, opf);\n\n    findContributorInMeta(publication, undefined, opf);\n\n    await fillSpineAndResource(publication, undefined, opf, zip, addLinkData);\n\n    fillTOC(publication, opf, ncx);\n\n    fillSubject(publication, opf);\n\n    fillPublicationDate(publication, undefined, opf);\n\n    return publication;\n}\n\nconst addLinkData = async (\n    publication: Publication, _rootfile: Rootfile | undefined,\n    opf: OPF, zip: IZip, linkItem: Link, item: Manifest) => {\n\n    if (publication.Metadata?.AdditionalJSON) {\n\n        // TODO: textPartAudio / audioPartText?? audioOnly??\n        // https://www.daisy.org/z3986/specifications/Z39-86-2002.html#Type\n        // https://www.daisy.org/z3986/specifications/daisy_202.html\n\n        const isFullTextAudio =\n            // dtb:multimediaContent ==> audio,text\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioFullText\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"audioFullText\" || (\n                !publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] &&\n                !publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"]\n            );\n\n        const isAudioOnly =\n            // dtb:multimediaContent ==> audio\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioNCX\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"audioNcc\";\n\n        const isTextOnly =\n            // dtb:multimediaContent ==> text\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"textNCX\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"textNcc\";\n\n        if (isFullTextAudio || isTextOnly || isAudioOnly) {\n            await addMediaOverlaySMIL(linkItem, item, opf, zip);\n\n            if (linkItem.MediaOverlays && !linkItem.MediaOverlays.initialized) {\n\n                // debug(\n                //     global.JSON.stringify(TaJsonSerialize(publication), null, 4),\n                //     global.JSON.stringify(linkItem, null, 4));\n\n                // if (process.env) {\n                //     throw new Error(\"BREAK\");\n                // }\n\n                // mo.initialized true/false is automatically handled\n                await lazyLoadMediaOverlays(publication, linkItem.MediaOverlays);\n\n                if (isFullTextAudio || isAudioOnly) {\n                    updateDurations(linkItem.MediaOverlays.duration, linkItem);\n                }\n            }\n        }\n    }\n};\n"]}