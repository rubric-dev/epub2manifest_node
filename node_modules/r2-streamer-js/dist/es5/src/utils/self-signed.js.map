{"version":3,"file":"self-signed.js","sourceRoot":"","sources":["../../../../src/utils/self-signed.ts"],"names":[],"mappings":";;;;AAOA,+BAAiC;AACjC,uCAAyC;AACzC,6BAAoC;AAgBpC,SAAsB,sBAAsB;;;YACxC,WAAO,IAAI,OAAO,CAAkB,UAAC,OAAO,EAAE,MAAM;oBAChD,IAAM,IAAI,GAAG;wBACT,SAAS,EAAE,QAAQ;wBAGnB,IAAI,EAAE,EAAE;wBACR,UAAU,EAAE,CAAC;gCACT,QAAQ,EAAE,CAAC;wCACP,IAAI,EAAE,CAAC;wCACP,KAAK,EAAE,WAAW;qCACrB,CAAC;gCACF,IAAI,EAAE,gBAAgB;6BACzB,CAAC;qBACL,CAAC;oBACF,IAAM,IAAI,GAAG,SAAM,EAAE,CAAC;oBACtB,IAAM,UAAU,GAAG,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,qBAAqB,GAAG,IAAI,EAAE,CAAC,CAAC;oBAEjF,UAAU,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,EAAE,UAAC,GAAQ,EAAE,IAAS;wBACtD,IAAI,GAAG,EAAE;4BACL,MAAM,CAAC,GAAG,CAAC,CAAC;4BACZ,OAAO;yBACV;wBAED,IAAM,QAAQ,GAAG,SAAM,EAAE,CAAC;wBAI1B,IAAM,IAAI,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;wBACpD,IAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;wBAClF,IAAwB,CAAC,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;wBAE7D,IAAwB,CAAC,UAAU,GAAG,SAAM,EAAE,CAAC;wBAEhD,IAAM,cAAc,GAAG,EAAE,CAAC;wBAC1B,IAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,SAAM,EAAE,CAAC,CAAC;wBACrC,IAAM,EAAE,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;wBAC1C,IAAwB,CAAC,YAAY,GAAG,EAAE,CAAC;wBAE5C,OAAO,CAAC,IAAuB,CAAC,CAAC;oBACrC,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AA1CD,wDA0CC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as crypto from \"crypto\";\nimport * as selfsigned from \"selfsigned\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport interface CertificateData {\n    trustKey: Buffer;\n    trustCheck: string;\n    trustCheckIV: Buffer;\n\n    // clientprivate?: string;\n    // clientpublic?: string;\n    // clientcert?: string;\n\n    private?: string; // https.ServerOptions.key\n    public?: string;\n    cert?: string; // https.ServerOptions.cert\n}\n\nexport async function generateSelfSignedData(): Promise<CertificateData> {\n    return new Promise<CertificateData>((resolve, reject) => {\n        const opts = {\n            algorithm: \"sha256\",\n            // clientCertificate: true,\n            // clientCertificateCN: \"R2 insecure client\",\n            days: 30,\n            extensions: [{\n                altNames: [{\n                    type: 2, // DNSName\n                    value: \"localhost\",\n                }],\n                name: \"subjectAltName\",\n            }],\n        };\n        const rand = uuidv4();\n        const attributes = [{ name: \"commonName\", value: \"R2 insecure server \" + rand }];\n\n        selfsigned.generate(attributes, opts, (err: any, keys: any) => {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            const password = uuidv4();\n            // const checkSum = crypto.createHash(\"sha256\");\n            // checkSum.update(password);\n            // const hash = checkSum.digest(\"hex\").toUpperCase();\n            const salt = crypto.randomBytes(16).toString(\"hex\");\n            const hash = crypto.pbkdf2Sync(password, salt, 1000, 32, \"sha256\").toString(\"hex\");\n            (keys as CertificateData).trustKey = Buffer.from(hash, \"hex\");\n\n            (keys as CertificateData).trustCheck = uuidv4();\n\n            const AES_BLOCK_SIZE = 16;\n            const ivBuff = Buffer.from(uuidv4());\n            const iv = ivBuff.slice(0, AES_BLOCK_SIZE);\n            (keys as CertificateData).trustCheckIV = iv;\n\n            resolve(keys as CertificateData);\n        });\n    });\n}\n"]}