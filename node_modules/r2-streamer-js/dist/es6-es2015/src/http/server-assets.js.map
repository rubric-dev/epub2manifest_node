{"version":3,"file":"server-assets.js","sourceRoot":"","sources":["../../../../src/http/server-assets.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as express from \"express\";\nimport * as mime from \"mime-types\";\nimport * as path from \"path\";\n\nimport { zipHasEntry } from \"@r2-shared-js/_utils/zipHasEntry\";\nimport { Publication } from \"@r2-shared-js/models/publication\";\nimport { Link } from \"@r2-shared-js/models/publication-link\";\nimport { Transformers } from \"@r2-shared-js/transform/transformer\";\nimport { parseRangeHeader } from \"@r2-utils-js/_utils/http/RangeUtils\";\nimport { streamToBufferPromise } from \"@r2-utils-js/_utils/stream/BufferUtils\";\nimport { IStreamAndLength, IZip } from \"@r2-utils-js/_utils/zip/zip\";\n\nimport {\n    IRequestPayloadExtension, IRequestQueryParams, URL_PARAM_SESSION_INFO, _asset, _pathBase64,\n} from \"./request-ext\";\nimport { Server } from \"./server\";\n\n// import { CounterPassThroughStream } from \"@r2-utils-js/_utils/stream/CounterPassThroughStream\";\n// import { PassThrough } from \"stream\";\n\nconst debug = debug_(\"r2:streamer#http/server-assets\");\n\nexport function serverAssets(server: Server, routerPathBase64: express.Router) {\n\n    // let streamCounter = 0;\n\n    const routerAssets = express.Router({ strict: false });\n    // routerAssets.use(morgan(\"combined\"), { stream: { write: (msg: any) => debug(msg) } }));\n\n    routerAssets.get(\"/\",\n        async (req: express.Request, res: express.Response) => {\n\n            const reqparams = (req as IRequestPayloadExtension).params;\n\n            if (!reqparams.pathBase64) {\n                reqparams.pathBase64 = (req as IRequestPayloadExtension).pathBase64;\n            }\n            if (!reqparams.asset) {\n                reqparams.asset = (req as IRequestPayloadExtension).asset;\n            }\n            if (!reqparams.lcpPass64) {\n                reqparams.lcpPass64 = (req as IRequestPayloadExtension).lcpPass64;\n            }\n\n            const isShow = (req.query as IRequestQueryParams).show;\n\n            // debug(req.method);\n            const isHead = req.method.toLowerCase() === \"head\";\n            if (isHead) {\n                debug(\"HEAD !!!!!!!!!!!!!!!!!!!\");\n            }\n\n            // reqparams.pathBase64 is already decoded!\n            // const decoded = decodeURIComponent(reqparams.pathBase64);\n            const pathBase64Str = Buffer.from(reqparams.pathBase64, \"base64\").toString(\"utf8\");\n\n            // const fileName = path.basename(pathBase64Str);\n            // const ext = path.extname(fileName).toLowerCase();\n\n            let publication: Publication;\n            try {\n                publication = await server.loadOrGetCachedPublication(pathBase64Str);\n            } catch (err) {\n                debug(err);\n                res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                    + err + \"</p></body></html>\");\n                return;\n            }\n\n            // dumpPublication(publication);\n\n            const zipInternal = publication.findFromInternal(\"zip\");\n            if (!zipInternal) {\n                const err = \"No publication zip!\";\n                debug(err);\n                res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                    + err + \"</p></body></html>\");\n                return;\n            }\n            const zip = zipInternal.Value as IZip;\n\n            const pathInZip = reqparams.asset;\n\n            if (!zipHasEntry(zip, pathInZip, undefined)) {\n                const err = \"Asset not in zip! \" + pathInZip;\n                debug(err);\n                res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                    + err + \"</p></body></html>\");\n                return;\n            }\n\n            const isDivina = publication.Metadata && publication.Metadata.RDFType &&\n                (/http[s]?:\\/\\/schema\\.org\\/ComicStory$/.test(publication.Metadata.RDFType) ||\n                /http[s]?:\\/\\/schema\\.org\\/VisualNarrative$/.test(publication.Metadata.RDFType));\n\n            let link: Link | undefined;\n\n            const findLinkRecursive = (relativePath: string, l: Link): Link | undefined => {\n                if (l.Href === relativePath) {\n                    return l;\n                }\n                let found: Link | undefined;\n                if (l.Children) {\n                    for (const child of l.Children) {\n                        found = findLinkRecursive(relativePath, child);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n                if (l.Alternate) {\n                    for (const alt of l.Alternate) {\n                        found = findLinkRecursive(relativePath, alt);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            if ((publication.Resources || publication.Spine || publication.Links)\n                && pathInZip.indexOf(\"META-INF/\") !== 0\n                && !pathInZip.endsWith(\".opf\")) {\n\n                const relativePath = pathInZip;\n\n                if (publication.Resources) {\n                    for (const l of publication.Resources) {\n                        link = findLinkRecursive(relativePath, l);\n                        if (link) {\n                            break;\n                        }\n                    }\n                }\n                if (!link) {\n                    if (publication.Spine) {\n                        for (const l of publication.Spine) {\n                            link = findLinkRecursive(relativePath, l);\n                            if (link) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!link) {\n                    if (publication.Links) {\n                        for (const l of publication.Links) {\n                            link = findLinkRecursive(relativePath, l);\n                            if (link) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!link &&\n                    !isDivina) {\n                    const err = \"Asset not declared in publication spine/resources!\" + relativePath;\n                    debug(err);\n                    res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                        + err + \"</p></body></html>\");\n                    return;\n                }\n            }\n\n            if (server.isSecured() && !link &&\n                (pathInZip.indexOf(\"META-INF/\") === 0 || pathInZip.endsWith(\".opf\"))\n            ) {\n                res.status(200).send(\"<html><body></body></html>\");\n                return;\n            }\n\n            let mediaType = mime.lookup(pathInZip);\n            if (link && link.TypeLink) {\n                mediaType = link.TypeLink;\n            }\n\n            const isText = (typeof mediaType === \"string\") && (\n                mediaType.indexOf(\"text/\") === 0 ||\n                mediaType.indexOf(\"application/xhtml\") === 0 ||\n                mediaType.indexOf(\"application/xml\") === 0 ||\n                mediaType.indexOf(\"application/json\") === 0 ||\n                mediaType.indexOf(\"application/svg\") === 0 ||\n                mediaType.indexOf(\"application/smil\") === 0 ||\n                mediaType.indexOf(\"+json\") > 0 ||\n                mediaType.indexOf(\"+smil\") > 0 ||\n                mediaType.indexOf(\"+svg\") > 0 ||\n                mediaType.indexOf(\"+xhtml\") > 0 ||\n                mediaType.indexOf(\"+xml\") > 0);\n\n            // const isVideoAudio = mediaType && (\n            //     mediaType.indexOf(\"audio/\") === 0 ||\n            //     mediaType.indexOf(\"video/\") === 0);\n            // if (isVideoAudio) {\n            //     debug(req.headers);\n            // }\n\n            const isEncrypted = link && link.Properties && link.Properties.Encrypted;\n            // const isObfuscatedFont = isEncrypted && link &&\n            //     (link.Properties.Encrypted.Algorithm === \"http://ns.adobe.com/pdf/enc#RC\"\n            //         || link.Properties.Encrypted.Algorithm === \"http://www.idpf.org/2008/embedding\");\n\n            const isPartialByteRangeRequest = ((req.headers && req.headers.range) ? true : false);\n\n            // if (isEncrypted && isPartialByteRangeRequest) {\n            //     const err = \"Encrypted video/audio not supported (HTTP 206 partial request byte range)\";\n            //     debug(err);\n            //     res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n            //         + err + \"</p></body></html>\");\n            //     return;\n            // }\n\n            let partialByteBegin = 0; // inclusive boundaries\n            let partialByteEnd = -1;\n            if (isPartialByteRangeRequest) {\n                debug(req.headers.range);\n                const ranges = parseRangeHeader(req.headers.range);\n                // debug(ranges);\n\n                if (ranges && ranges.length) {\n                    if (ranges.length > 1) {\n                        const err = \"Too many HTTP ranges: \" + req.headers.range;\n                        debug(err);\n                        // res.set(\"Content-Range\", `*/${contentLength}`);\n                        res.status(416).send(\"<html><body><p>Internal Server Error</p><p>\"\n                            + err + \"</p></body></html>\");\n                        return;\n                    }\n                    partialByteBegin = ranges[0].begin;\n                    partialByteEnd = ranges[0].end;\n\n                    if (partialByteBegin < 0) {\n                        partialByteBegin = 0;\n                    }\n                }\n\n                debug(`${pathInZip} >> ${partialByteBegin}-${partialByteEnd}`);\n            }\n            let zipStream_: IStreamAndLength;\n            try {\n                zipStream_ = isPartialByteRangeRequest && !isEncrypted ?\n                    await zip.entryStreamRangePromise(pathInZip, partialByteBegin, partialByteEnd) :\n                    await zip.entryStreamPromise(pathInZip);\n            } catch (err) {\n                debug(err);\n                res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                    + err + \"</p></body></html>\");\n                return;\n            }\n\n            // The HTML transforms are chained here too, so cannot check server.disableDecryption at this level!\n            const doTransform = true; // !isEncrypted || (isObfuscatedFont || !server.disableDecryption);\n\n            const sessionInfo = (req.query as IRequestQueryParams)[URL_PARAM_SESSION_INFO];\n\n            if (doTransform && link) {\n\n                const fullUrl = `${server.serverUrl()}${req.originalUrl}`;\n\n                let transformedStream: IStreamAndLength;\n                try {\n                    transformedStream = await Transformers.tryStream(\n                        publication,\n                        link,\n                        fullUrl,\n                        zipStream_,\n                        isPartialByteRangeRequest,\n                        partialByteBegin,\n                        partialByteEnd,\n                        sessionInfo,\n                    );\n                } catch (err) {\n                    debug(err);\n                    res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                        + err + \"</p></body></html>\");\n                    return;\n                }\n                if (transformedStream) {\n                    if (transformedStream !== zipStream_) {\n                        debug(\"Asset transformed ok: \" + link.Href);\n                    }\n                    zipStream_ = transformedStream; // can be unchanged\n                } else {\n                    const err = \"Transform fail (encryption scheme not supported?)\";\n                    debug(err);\n                    res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                        + err + \"</p></body></html>\");\n                    return;\n                }\n            }\n\n            if (isShow) {\n                let zipData: Buffer;\n                try {\n                    zipData = await streamToBufferPromise(zipStream_.stream);\n                } catch (err) {\n                    debug(err);\n                    res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                        + err + \"</p></body></html>\");\n                    return;\n                }\n                if (zipData) {\n                    debug(\"CHECK: \" + zipStream_.length + \" ==> \" + zipData.length);\n                }\n                res.status(200).send(\"<html><body>\" +\n                    \"<h1>\" + path.basename(pathBase64Str) + \"</h1>\" +\n                    \"<h2>\" + mediaType + \"</h2>\" +\n                    ((isText && zipData) ?\n                        (\"<p><pre>\" +\n                            zipData.toString(\"utf8\").replace(/&/g, \"&amp;\")\n                                .replace(/</g, \"&lt;\")\n                                .replace(/>/g, \"&gt;\")\n                                .replace(/\"/g, \"&quot;\")\n                                .replace(/'/g, \"&apos;\") +\n                            \"</pre></p>\")\n                        : \"<p>BINARY</p>\"\n                    ) + \"</body></html>\");\n\n                return;\n            }\n\n            server.setResponseCORS(res);\n\n            if (isPartialByteRangeRequest || isEncrypted) {\n                server.setResponseCacheHeaders(res, false);\n            } else {\n                server.setResponseCacheHeaders(res, true);\n            }\n\n            if (mediaType) {\n                res.set(\"Content-Type\", mediaType);\n                // res.type(mediaType);\n            }\n\n            res.setHeader(\"Accept-Ranges\", \"bytes\");\n\n            if (isPartialByteRangeRequest) {\n                if (partialByteEnd < 0) {\n                    partialByteEnd = zipStream_.length - 1;\n                }\n                const partialByteLength = isPartialByteRangeRequest ?\n                    partialByteEnd - partialByteBegin + 1 :\n                    zipStream_.length;\n                // res.setHeader(\"Connection\", \"close\");\n                // res.setHeader(\"Transfer-Encoding\", \"chunked\");\n                res.setHeader(\"Content-Length\", `${partialByteLength}`);\n                const rangeHeader = `bytes ${partialByteBegin}-${partialByteEnd}/${zipStream_.length}`;\n                // debug(\"+++> \" + rangeHeader + \" (( \" + partialByteLength);\n                res.setHeader(\"Content-Range\", rangeHeader);\n                res.status(206);\n            } else {\n                res.setHeader(\"Content-Length\", `${zipStream_.length}`);\n                // debug(\"---> \" + zipStream_.length);\n                res.status(200);\n            }\n\n            if (isHead) {\n                res.end();\n                // } else if (!isPartialByteRangeRequest && zipStream_.length &&\n                //     mediaType && mediaType.indexOf(\"html\") >= 0) {\n\n                //     debug(\"===> BUFFER SEND (bypass streaming)\");\n                //     let zipData: Buffer;\n                //     try {\n                //         zipData = await streamToBufferPromise(zipStream_.stream);\n                //     } catch (err) {\n                //         debug(err);\n                //         res.status(500).send(\"<html><body><p>Internal Server Error</p><p>\"\n                //             + err + \"</p></body></html>\");\n                //         return;\n                //     }\n                //     if (zipData) {\n                //         debug(\"CHECK: \" + zipStream_.length + \" ==> \" + zipData.length);\n                //     }\n                //     debug(\"HTMLHTMLHTMLHTMLHTMLHTMLHTML\");\n                //     debug(zipData.toString(\"utf8\"));\n                //     debug(\"HTMLHTMLHTMLHTMLHTMLHTMLHTML\");\n                //     // res.send(zipStream_.stream);\n                //     res.send(zipData);\n            } else {\n\n                // const counterStream = new CounterPassThroughStream(++streamCounter);\n                // debug(`===> STREAM PIPE [${counterStream.id}] ${link ? link.Href : \"link?\"} /// ${pathInZip}`);\n\n                zipStream_.stream // readable\n                    .on(\"error\", function f(this: ReadableStream) {\n                        debug(\"ZIP ERROR \" + pathInZip);\n                    })\n                    // .on(\"finish\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP FINISH \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"end\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP END \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"close\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP CLOSE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"error\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP ERROR \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pipe\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP PIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"unpipe\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP UNPIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"drain\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP DRAIN \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pause\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP PAUSE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"resume\", function f(this: ReadableStream) {\n                    //     debug(\"ZIP RESUME \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .pipe(counterStream) // readable (zipStream_.stream) --> writable (counterStream is duplex)\n                    // .on(\"progress\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream PROGRESS: \" +\n                    //         this.id + \" -- \" + this.bytesReceived + \" = \" + pathInZip);\n                    // })\n                    // .on(\"finish\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream FINISH: \" +\n                    //         this.id +\n                    //         \" -- \" + this.bytesReceived + \" = \" + pathInZip);\n                    // })\n                    // .on(\"end\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream END: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"close\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream CLOSE: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"error\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream ERROR: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pipe\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream PIPE: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"unpipe\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream UNPIPE: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"drain\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream DRAIN: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pause\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream PAUSE: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"resume\", function f(this: CounterPassThroughStream) {\n                    //     debug(\"CounterPassThroughStream RESUME: \" +\n                    //         this.id + \" = \" + pathInZip);\n                    // })\n                    // readable (counterStream is duplex) --> writable (PassThrough is duplex)\n                    // .pipe(new PassThrough())\n                    // .on(\"finish\", function f(this: PassThrough) {\n                    //     debug(\"PASS FINISH \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"end\", function f(this: PassThrough) {\n                    //     debug(\"PASS END \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"close\", function f(this: PassThrough) {\n                    //     debug(\"PASS CLOSE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"error\", function f(this: PassThrough) {\n                    //     debug(\"PASS ERROR \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pipe\", function f(this: PassThrough) {\n                    //     debug(\"PASS PIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"unpipe\", function f(this: PassThrough) {\n                    //     debug(\"PASS UNPIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"drain\", function f(this: PassThrough) {\n                    //     debug(\"PASS DRAIN \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pause\", function f(this: PassThrough) {\n                    //     debug(\"PASS PAUSE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"resume\", function f(this: PassThrough) {\n                    //     debug(\"PASS RESUME \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    .pipe(res) // readable (counterStream is duplex) --> writable (res)\n                    .on(\"error\", function f(this: express.Response) {\n                        debug(\"RES ERROR \" + pathInZip);\n                    })\n                    .on(\"close\", function f(this: express.Response) {\n\n                        res.end(); // writable\n                    })\n                    // .on(\"finish\", function f(this: express.Response) {\n                    //     debug(\"RES FINISH \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"end\", function f(this: express.Response) {\n                    //     debug(\"RES END \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"close\", function f(this: express.Response) {\n                    //     debug(\"RES CLOSE \" + counterStream.id + \" = \" + pathInZip);\n\n                    //     res.end(); // writable\n\n                    //     // // readable (counterStream is duplex) --> writable (res)\n                    //     // counterStream.unpipe(res);\n\n                    //     // // duplex writable + readable\n                    //     // counterStream.end();\n\n                    //     // // readable (zipStream_.stream) --> writable (counterStream is duplex)\n                    //     // zipStream_.stream.unpipe(counterStream);\n\n                    //     // // zipStream_.stream.close();\n                    // })\n                    // .on(\"error\", function f(this: express.Response) {\n                    //     debug(\"RES ERROR \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pipe\", function f(this: express.Response) {\n                    //     debug(\"RES PIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"unpipe\", function f(this: express.Response) {\n                    //     debug(\"RES UNPIPE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"drain\", function f(this: express.Response) {\n                    //     debug(\"RES DRAIN \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"pause\", function f(this: express.Response) {\n                    //     debug(\"RES PAUSE \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    // .on(\"resume\", function f(this: express.Response) {\n                    //     debug(\"RES RESUME \" + counterStream.id + \" = \" + pathInZip);\n                    // })\n                    ;\n            }\n        });\n\n    routerPathBase64.param(\"asset\", (req, _res, next, value, _name) => {\n        // At this point, route relative path is already normalised with respect to /../ and /./ dot segments,\n        // but not double slashes (which seems to be an easy mistake to make at authoring time in EPUBs),\n        // so we collapse multiple slashes into a single one.\n        if (value) {\n            value = value.replace(/\\/\\/+/g, \"/\");\n        }\n\n        (req as IRequestPayloadExtension).asset = value;\n        next();\n    });\n\n    routerPathBase64.use(\"/:\" + _pathBase64 + \"/:\" + _asset + \"(*)\", routerAssets);\n}\n"]}