{"version":3,"file":"BufferUtils.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/BufferUtils.ts"],"names":[],"mappings":";;AAWA,wCAiEC;AAED,wEAoDC;AAED,sDAgCC;;AA7JD,+DAA8D;AAI9D,SAAgB,cAAc,CAAC,MAAc;IAEzC,OAAO,IAAI,2CAAoB,CAAC,MAAM,CAAC,CAAC;AA+D5C,CAAC;AAED,SAAsB,8BAA8B,CAAC,UAAiC;;;YAElF,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,IAAM,OAAO,GAAG;wBACZ,UAAU,CAAC,cAAc,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;wBACtD,UAAU,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;oBAEpD,CAAC,CAAC;oBAGF,IAAM,WAAW,GAAG,UAAC,CAAM;wBACvB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBACf,OAAO,EAAE,CAAC;wBAEV,MAAM,CAAC,CAAC,CAAC,CAAC;oBACd,CAAC,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;oBAEpC,IAAM,cAAc,GAAG;wBACnB,IAAI,KAAa,CAAC;wBAClB,GAAG,CAAC;4BACA,KAAK,GAAG,UAAU,CAAC,IAAI,EAAY,CAAC;4BACpC,IAAI,KAAK,EAAE,CAAC;gCACR,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;4BACxB,CAAC;wBACL,CAAC,QACM,KAAK,EAAE;wBAEd,MAAM,EAAE,CAAC;oBACb,CAAC,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;oBAE1C,IAAI,QAAQ,GAAG,KAAK,CAAC;oBACrB,IAAM,MAAM,GAAG;wBACX,IAAI,QAAQ,EAAE,CAAC;4BACX,OAAO;wBACX,CAAC;wBACD,QAAQ,GAAG,IAAI,CAAC;wBAEhB,OAAO,EAAE,CAAC;wBACV,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC;gBAON,CAAC,CAAC,EAAC;;;CACN;AAED,SAAsB,qBAAqB,CAAC,UAAiC;;;YAEzE,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,IAAM,OAAO,GAAG;wBACZ,UAAU,CAAC,cAAc,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;wBAC9C,UAAU,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;wBAChD,UAAU,CAAC,cAAc,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;oBAChD,CAAC,CAAC;oBAGF,IAAM,WAAW,GAAG,UAAC,CAAM;wBACvB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBACf,OAAO,EAAE,CAAC;wBAEV,MAAM,CAAC,CAAC,CAAC,CAAC;oBACd,CAAC,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;oBAEpC,IAAM,UAAU,GAAG,UAAC,IAAY;wBAC5B,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACvB,CAAC,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;oBAElC,IAAM,SAAS,GAAG;wBACd,OAAO,EAAE,CAAC;wBACV,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC;oBACF,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;gBACpC,CAAC,CAAC,EAAC;;;CACN","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { BufferReadableStream } from \"./BufferReadableStream\";\n\n// import { PassThrough } from \"stream\";\n\nexport function bufferToStream(buffer: Buffer): NodeJS.ReadableStream {\n\n    return new BufferReadableStream(buffer);\n\n    // const stream = new PassThrough();\n\n    // setTimeout(() => {\n\n    //     // stream.write(buffer);\n    //     // stream.end();\n\n    //     // const maxBuffLength = 2048; // 2kB\n    //     let maxBuffLength = 100 * 1024; // 100kB\n\n    //     let buff = buffer;\n    //     let remaining = buff.length;\n    //     let done = 0;\n\n    //     console.log(\"bufferToStream()  BEFORE: \" + remaining);\n\n    //     while (remaining > 0) {\n\n    //         if (done > 0) {\n    //             buff = buffer.slice(done);\n    //             // remaining === buff.length\n    //         }\n\n    //         if (buff.length > maxBuffLength) {\n    //             buff = buff.slice(0, maxBuffLength);\n    //         }\n\n    //         const res = stream.write(buff);\n    //         if (!res) {\n    //             console.log(\"bufferToStream()  highWaterMark\");\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._writableState) {\n    //                 const internalStreamWriteBuffer = (stream as any)._writableState.getBuffer();\n    //                 if (internalStreamWriteBuffer) {\n    //                     console.log(\"bufferToStream() _writableState.getBuffer().length: \"\n    // + internalStreamWriteBuffer.length);\n    //                 }\n    //             }\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._readableState) {\n    //                 const internalStreamReadBuffer = (stream as any)._readableState.buffer;\n    //                 if (internalStreamReadBuffer) {\n    //                     console.log(\"bufferToStream() _readableState.buffer.length: \"\n    // + internalStreamReadBuffer.length);\n    //                 }\n    //             }\n\n    //         }\n\n    //         done += buff.length;\n    //         remaining -= buff.length;\n    //     }\n\n    //     console.log(\"bufferToStream()  AFTER: \" + done);\n\n    //     stream.end();\n    // }, 20);\n\n    // return stream;\n}\n\nexport async function streamToBufferPromise_READABLE(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        const cleanup = () => {\n            readStream.removeListener(\"readable\", handleReadable);\n            readStream.removeListener(\"error\", handleError);\n            // readStream.removeListener(\"end\", handleEnd);\n        };\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const handleError = (e: any) => {\n            console.log(e);\n            cleanup();\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(e);\n        };\n        readStream.on(\"error\", handleError);\n\n        const handleReadable = () => {\n            let chunk: Buffer;\n            do {\n                chunk = readStream.read() as Buffer;\n                if (chunk) {\n                    buffers.push(chunk);\n                }\n            }\n            while (chunk);\n\n            finish();\n        };\n        readStream.on(\"readable\", handleReadable);\n\n        let finished = false;\n        const finish = () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n\n            cleanup();\n            resolve(Buffer.concat(buffers));\n        };\n\n        // // With NodeJS v8, this event is raised. Not with NodeJS 10+\n        // const handleEnd = () => {\n        //     finish();\n        // };\n        // readStream.on(\"end\", finish);\n    });\n}\n\nexport async function streamToBufferPromise(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        const cleanup = () => {\n            readStream.removeListener(\"data\", handleData);\n            readStream.removeListener(\"error\", handleError);\n            readStream.removeListener(\"end\", handleEnd);\n        };\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const handleError = (e: any) => {\n            console.log(e);\n            cleanup();\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(e);\n        };\n        readStream.on(\"error\", handleError);\n\n        const handleData = (data: Buffer) => {\n            buffers.push(data);\n        };\n        readStream.on(\"data\", handleData);\n\n        const handleEnd = () => {\n            cleanup();\n            resolve(Buffer.concat(buffers));\n        };\n        readStream.on(\"end\", handleEnd);\n    });\n}\n"]}