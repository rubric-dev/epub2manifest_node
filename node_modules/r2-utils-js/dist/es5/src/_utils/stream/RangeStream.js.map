{"version":3,"file":"RangeStream.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/RangeStream.ts"],"names":[],"mappings":";;;;AAOA,8BAAgC;AAChC,iCAAmC;AAEnC,IAAM,KAAK,GAAG,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAEpD;IAAiC,uCAAS;IAKtC,qBAAqB,WAAmB,EAAW,SAAiB,EAAW,YAAoB;QAC/F,YAAA,MAAK,WAAE,SAAC;QADS,iBAAW,GAAX,WAAW,CAAQ;QAAW,eAAS,GAAT,SAAS,CAAQ;QAAW,kBAAY,GAAZ,YAAY,CAAQ;QAE/F,KAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,KAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,KAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,KAAI,CAAC,EAAE,CAAC,KAAK,EAAE;QAEf,CAAC,CAAC,CAAC;QACH,KAAI,CAAC,EAAE,CAAC,QAAQ,EAAE;QAElB,CAAC,CAAC,CAAC;;IACP,CAAC;IAEM,4BAAM,GAAb,UAAc,QAAoB;QAE9B,QAAQ,EAAE,CAAC;IACf,CAAC;IAEM,gCAAU,GAAjB,UAAkB,KAAa,EAAE,SAAiB,EAAE,QAAoB;QACpE,IAAI,CAAC,aAAa,IAAI,KAAK,CAAC,MAAM,CAAC;QAGnC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACjB,KAAK,CAAC,iBAAiB,CAAC,CAAC;gBACzB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACpB,CAAC;iBAAM,CAAC;gBACJ,KAAK,CAAC,wCAAwC,CAAC,CAAC;gBAChD,IAAI,CAAC,GAAG,EAAE,CAAC;YACf,CAAC;QACL,CAAC;aAAM,CAAC;YACJ,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;gBAExC,IAAI,UAAU,GAAG,CAAC,CAAC;gBACnB,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;gBAEhC,UAAU,GAAG,IAAI,CAAC,WAAW,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;gBACpE,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC;oBACjB,UAAU,GAAG,CAAC,CAAC;gBACnB,CAAC;gBAED,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;oBACtC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;gBACpE,CAAC;gBAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;gBAEjD,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;oBAEhB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChB,IAAI,CAAC,GAAG,EAAE,CAAC;gBACf,CAAC;YACL,CAAC;iBAAM,CAAC;YAGR,CAAC;QACL,CAAC;QAED,QAAQ,EAAE,CAAC;IACf,CAAC;IACL,kBAAC;AAAD,CAAC,AApED,CAAiC,kBAAS,GAoEzC;AApEY,kCAAW","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport { Transform } from \"stream\";\n\nconst debug = debug_(\"r2:utils#stream/RangeStream\");\n\nexport class RangeStream extends Transform {\n    private bytesReceived: number;\n    private finished: boolean;\n    private isClosed: boolean;\n\n    constructor(readonly streamBegin: number, readonly streamEnd: number, readonly streamLength: number) {\n        super();\n        this.bytesReceived = 0;\n        this.finished = false;\n        this.isClosed = false;\n        this.on(\"end\", () => {\n            // debug(\"------ RangeStream END\");\n        });\n        this.on(\"finish\", () => {\n            // debug(\"------ RangeStream FINISH\");\n        });\n    }\n\n    public _flush(callback: () => void): void {\n        // debug(\"FLUSH\");\n        callback();\n    }\n\n    public _transform(chunk: Buffer, _encoding: string, callback: () => void): void {\n        this.bytesReceived += chunk.length;\n        // debug(`_transform bytesReceived ${this.bytesReceived}`);\n\n        if (this.finished) {\n            if (!this.isClosed) {\n                debug(\"???? CLOSING...\");\n                this.isClosed = true;\n                this.push(null);\n            } else {\n                debug(\"???? STILL PIPE CALLING _transform ??!\");\n                this.end();\n            }\n        } else {\n            if (this.bytesReceived > this.streamBegin) {\n\n                let chunkBegin = 0;\n                let chunkEnd = chunk.length - 1;\n\n                chunkBegin = this.streamBegin - (this.bytesReceived - chunk.length);\n                if (chunkBegin < 0) {\n                    chunkBegin = 0;\n                }\n\n                if (this.bytesReceived > this.streamEnd) {\n                    this.finished = true;\n                    chunkEnd = chunk.length - (this.bytesReceived - this.streamEnd);\n                }\n                // console.log(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\n                this.push(chunk.slice(chunkBegin, chunkEnd + 1));\n\n                if (this.finished) {\n                    // debug(\"FINISHING...\");\n                    this.isClosed = true;\n                    this.push(null);\n                    this.end();\n                }\n            } else {\n                // NOOP\n                // no call to this.push(), we skip the entire current chunk buffer\n            }\n        }\n\n        callback();\n    }\n}\n"]}