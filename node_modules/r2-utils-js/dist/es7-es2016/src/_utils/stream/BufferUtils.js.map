{"version":3,"file":"BufferUtils.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/BufferUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { BufferReadableStream } from \"./BufferReadableStream\";\n\n// import { PassThrough } from \"stream\";\n\nexport function bufferToStream(buffer: Buffer): NodeJS.ReadableStream {\n\n    return new BufferReadableStream(buffer);\n\n    // const stream = new PassThrough();\n\n    // setTimeout(() => {\n\n    //     // stream.write(buffer);\n    //     // stream.end();\n\n    //     // const maxBuffLength = 2048; // 2kB\n    //     let maxBuffLength = 100 * 1024; // 100kB\n\n    //     let buff = buffer;\n    //     let remaining = buff.length;\n    //     let done = 0;\n\n    //     console.log(\"bufferToStream()  BEFORE: \" + remaining);\n\n    //     while (remaining > 0) {\n\n    //         if (done > 0) {\n    //             buff = buffer.slice(done);\n    //             // remaining === buff.length\n    //         }\n\n    //         if (buff.length > maxBuffLength) {\n    //             buff = buff.slice(0, maxBuffLength);\n    //         }\n\n    //         const res = stream.write(buff);\n    //         if (!res) {\n    //             console.log(\"bufferToStream()  highWaterMark\");\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._writableState) {\n    //                 const internalStreamWriteBuffer = (stream as any)._writableState.getBuffer();\n    //                 if (internalStreamWriteBuffer) {\n    //                     console.log(\"bufferToStream() _writableState.getBuffer().length: \"\n    // + internalStreamWriteBuffer.length);\n    //                 }\n    //             }\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._readableState) {\n    //                 const internalStreamReadBuffer = (stream as any)._readableState.buffer;\n    //                 if (internalStreamReadBuffer) {\n    //                     console.log(\"bufferToStream() _readableState.buffer.length: \"\n    // + internalStreamReadBuffer.length);\n    //                 }\n    //             }\n\n    //         }\n\n    //         done += buff.length;\n    //         remaining -= buff.length;\n    //     }\n\n    //     console.log(\"bufferToStream()  AFTER: \" + done);\n\n    //     stream.end();\n    // }, 20);\n\n    // return stream;\n}\n\nexport async function streamToBufferPromise_READABLE(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        const cleanup = () => {\n            readStream.removeListener(\"readable\", handleReadable);\n            readStream.removeListener(\"error\", handleError);\n            // readStream.removeListener(\"end\", handleEnd);\n        };\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const handleError = (e: any) => {\n            console.log(e);\n            cleanup();\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(e);\n        };\n        readStream.on(\"error\", handleError);\n\n        const handleReadable = () => {\n            let chunk: Buffer;\n            do {\n                chunk = readStream.read() as Buffer;\n                if (chunk) {\n                    buffers.push(chunk);\n                }\n            }\n            while (chunk);\n\n            finish();\n        };\n        readStream.on(\"readable\", handleReadable);\n\n        let finished = false;\n        const finish = () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n\n            cleanup();\n            resolve(Buffer.concat(buffers));\n        };\n\n        // // With NodeJS v8, this event is raised. Not with NodeJS 10+\n        // const handleEnd = () => {\n        //     finish();\n        // };\n        // readStream.on(\"end\", finish);\n    });\n}\n\nexport async function streamToBufferPromise(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        const cleanup = () => {\n            readStream.removeListener(\"data\", handleData);\n            readStream.removeListener(\"error\", handleError);\n            readStream.removeListener(\"end\", handleEnd);\n        };\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const handleError = (e: any) => {\n            console.log(e);\n            cleanup();\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(e);\n        };\n        readStream.on(\"error\", handleError);\n\n        const handleData = (data: Buffer) => {\n            buffers.push(data);\n        };\n        readStream.on(\"data\", handleData);\n\n        const handleEnd = () => {\n            cleanup();\n            resolve(Buffer.concat(buffers));\n        };\n        readStream.on(\"end\", handleEnd);\n    });\n}\n"]}