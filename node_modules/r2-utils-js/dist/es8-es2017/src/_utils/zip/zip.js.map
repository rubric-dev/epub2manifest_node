{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../../../../src/_utils/zip/zip.ts"],"names":[],"mappings":";;;AAOA,uDAAoD;AAkBpD,MAAsB,GAAG;IAQd,KAAK,CAAC,uBAAuB,CAAC,SAAiB,EAAE,KAAa,EAAE,GAAW;QAE9E,IAAI,eAAiC,CAAC;QACtC,IAAI,CAAC;YACD,eAAe,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QAC/D,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACX,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAEjB,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC;QAED,MAAM,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAChC,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAIvD,MAAM,MAAM,GAAG,IAAI,yBAAW,CAAC,CAAC,EAAE,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,CAAC;QAE7D,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAEpC,MAAM,GAAG,GAAqB;YAC1B,MAAM,EAAE,eAAe,CAAC,MAAM;YAC9B,KAAK,EAAE,KAAK,IAAI,EAAE;gBACd,OAAO,IAAI,CAAC,uBAAuB,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;YAC/D,CAAC;YACD,MAAM;SACT,CAAC;QACF,OAAO,GAAG,CAAC;IACf,CAAC;CACJ;AArCD,kBAqCC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { RangeStream } from \"../stream/RangeStream\";\n\nexport interface IStreamAndLength {\n    stream: NodeJS.ReadableStream;\n    length: number;\n    reset: () => Promise<IStreamAndLength>;\n}\n\nexport interface IZip {\n    hasEntries: () => boolean;\n    entriesCount: () => number;\n    hasEntry: (entryPath: string) => boolean;\n    getEntries: () => Promise<string[]>;\n    entryStreamPromise: (entryPath: string) => Promise<IStreamAndLength>;\n    entryStreamRangePromise: (entryPath: string, begin: number, end: number) => Promise<IStreamAndLength>;\n    freeDestroy: () => void;\n}\n\nexport abstract class Zip implements IZip {\n    public abstract hasEntries(): boolean;\n    public abstract entriesCount(): number;\n    public abstract hasEntry(entryPath: string): boolean;\n    public abstract getEntries(): Promise<string[]>;\n    public abstract entryStreamPromise(entryPath: string): Promise<IStreamAndLength>;\n    public abstract freeDestroy(): void;\n\n    public async entryStreamRangePromise(entryPath: string, begin: number, end: number): Promise<IStreamAndLength> {\n\n        let streamAndLength: IStreamAndLength;\n        try {\n            streamAndLength = await this.entryStreamPromise(entryPath);\n        } catch (err) {\n            console.log(err);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(err);\n        }\n\n        const b = begin < 0 ? 0 : begin;\n        const e = end < 0 ? (streamAndLength.length - 1) : end;\n        // const length = e - b + 1;\n        // debug(`entryStreamRangePromise: ${b}-${e}/${streamAndLength.length}`);\n\n        const stream = new RangeStream(b, e, streamAndLength.length);\n\n        streamAndLength.stream.pipe(stream);\n\n        const sal: IStreamAndLength = {\n            length: streamAndLength.length,\n            reset: async () => {\n                return this.entryStreamRangePromise(entryPath, begin, end);\n            },\n            stream,\n        };\n        return sal;\n    }\n}\n"]}