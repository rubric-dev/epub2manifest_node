"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = void 0;
const util = require("util");
const converter_1 = require("./../converters/converter");
const object_definition_1 = require("../classes/object-definition");
function serialize(value, type, options = { keyToPreserveUnknownJSON: undefined }) {
    if (value.constructor === Array) {
        return value.map(o => serializeRootObject(o, type, options));
    }
    return serializeRootObject(value, type, options);
}
exports.serialize = serialize;
function serializeRootObject(object, type = Object.getPrototypeOf(object).constructor, options) {
    const inheritanceChain = object_definition_1.getTypedInheritanceChain(type);
    if (inheritanceChain.length === 0) {
        return object;
    }
    const definitions = inheritanceChain
        .map(t => object_definition_1.objectDefinitions.get(t))
        .filter(t => !!t); // Typescript doesn't yet support the undefined filter
    const output = {};
    definitions.forEach(d => {
        d.properties.forEach((p, key) => {
            if (!p.type) {
                throw new Error(`Cannot serialize property '${key}' without type!`);
            }
            const value = object[key];
            if (value == undefined || p.writeonly) {
                return;
            }
            if (p.set) {
                output[p.serializedName] = serializeArray(Array.from(value || []), p, options);
                return;
            }
            if (p.array) {
                output[p.serializedName] = serializeArray(value, p, options);
                return;
            }
            output[p.serializedName] = serializeObject(value, p, options);
        });
    });
    if (options.keyToPreserveUnknownJSON) {
        const anchor = options.keyToPreserveUnknownJSON;
        if (object[anchor]) {
            const jsonProps = Object.keys(object[anchor]);
            for (const jsonProp of jsonProps) {
                if (object[anchor].hasOwnProperty(jsonProp)) {
                    let property;
                    definitions.forEach(d => {
                        d.properties.forEach((p, key) => {
                            if (!property && jsonProp === p.serializedName) {
                                property = p;
                                // break
                            }
                        });
                    });
                    if (!property) {
                        if (typeof output[jsonProp] !== "undefined") {
                            console.log(`???!!! TAJSON keyToPreserveUnknownJSON already serialized?! ${anchor}.${jsonProp}`);
                            // breakLength: 100  maxArrayLength: undefined
                            // tslint:disable-next-line: max-line-length
                            console.log(util.inspect(output[jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            if (output[jsonProp] !== object[anchor][jsonProp]) {
                                console.log(`???!!! TAJSON keyToPreserveUnknownJSON already serialized DIFF?! ${anchor}.${jsonProp}`);
                                // breakLength: 100  maxArrayLength: undefined
                                // tslint:disable-next-line: max-line-length
                                console.log(util.inspect(object[anchor][jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            }
                        }
                        // warning: reference copy, not deep clone!
                        output[jsonProp] = object[anchor][jsonProp];
                    }
                }
            }
        }
    }
    return output;
}
function serializeArray(array, definition, options) {
    const arr = array.map(v => serializeObject(v, definition, options));
    if (arr.length === 1) {
        const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
        if (converter && converter.collapseArrayWithSingleItem()) {
            return arr[0];
        }
    }
    return arr;
}
function serializeObject(object, definition, options) {
    const primitive = definition.type === String || definition.type === Boolean || definition.type === Number;
    const value = object;
    const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
    if (converter) {
        return converter.serialize(value);
    }
    if (!primitive) {
        const objDefinition = object_definition_1.objectDefinitions.get(definition.type);
        if (objDefinition) {
            if (value instanceof definition.type) {
                return serialize(value, undefined, options);
            }
            return serialize(value, definition.type, options);
        }
    }
    return value;
}
