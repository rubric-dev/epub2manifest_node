var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import * as util from "util";
import { objectDefinitions, getTypedInheritanceChain } from "../classes/object-definition";
import { propertyConverters } from "../converters/converter";
export function deserialize(object, type, options) {
    if (options === void 0) { options = { runConstructor: false, keyToPreserveUnknownJSON: undefined }; }
    if (object && object.constructor === Array) {
        return object.map(function (o) { return deserializeRootObject(o, type, options); });
    }
    return deserializeRootObject(object, type, options);
}
function deserializeRootObject(object, objectType, options) {
    if (objectType === void 0) { objectType = Object; }
    if (!objectDefinitions.has(objectType)) {
        return object;
    }
    var values = object;
    var _a = getTypedInheritanceChain(objectType, values), type = _a[0], superTypes = _a.slice(1);
    var output = Object.create(type.prototype);
    var definitions = __spreadArrays(superTypes.reverse(), [type]).map(function (t) { return objectDefinitions.get(t); }).filter(function (t) { return !!t; });
    definitions.forEach(function (d) {
        if (options.runConstructor) {
            d.ctr.call(output);
        }
        d.beforeDeserialized.call(output);
        d.properties.forEach(function (p, key) {
            if (!p.type) {
                throw new Error("Cannot deserialize property '" + key + "' without type!");
            }
            var value = values[p.serializedName];
            if (value == undefined || p.readonly) {
                return;
            }
            if (p.array || p.set) {
                output[key] = deserializeArray(value, p, options);
                if (p.set) {
                    output[key] = new Set(output[key]);
                }
                return;
            }
            output[key] = deserializeObject(value, p, options);
        });
        d.onDeserialized.call(output);
    });
    if (options.keyToPreserveUnknownJSON) {
        var anchor_1 = options.keyToPreserveUnknownJSON;
        Object.keys(values).forEach(function (jsonProp) {
            if (values.hasOwnProperty(jsonProp)) {
                var property_1;
                definitions.forEach(function (d) {
                    d.properties.forEach(function (p, key) {
                        if (!property_1 && jsonProp === p.serializedName) {
                            property_1 = p;
                            // break
                        }
                    });
                    if (!property_1) {
                        if (!output[anchor_1]) {
                            output[anchor_1] = {};
                        }
                        if (typeof output[anchor_1][jsonProp] !== "undefined") {
                            // console.log(`???!!! TAJSON keyToPreserveUnknownJSON already deserialized?! ${anchor}.${jsonProp}`);
                            // // breakLength: 100  maxArrayLength: undefined
                            // tslint:disable-next-line: max-line-length
                            // console.log(util.inspect(output[anchor][jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            if (output[anchor_1][jsonProp] !== values[jsonProp]) {
                                console.log("???!!! TAJSON keyToPreserveUnknownJSON already deserialized DIFF?! " + anchor_1 + "." + jsonProp);
                                // breakLength: 100  maxArrayLength: undefined
                                // tslint:disable-next-line: max-line-length
                                console.log(util.inspect(values[jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            }
                        }
                        // warning: reference copy, not deep clone!
                        output[anchor_1][jsonProp] = values[jsonProp];
                    }
                    else if (output[anchor_1] && typeof output[anchor_1][jsonProp] !== "undefined") {
                        // note: jsonProp === property.serializedName
                        // output[anchor][jsonProp] = undefined;
                        delete output[anchor_1][jsonProp];
                    }
                });
            }
        });
        if (output[anchor_1] && !Object.keys(output[anchor_1]).length) {
            delete output[anchor_1];
        }
    }
    return output;
}
function deserializeArray(array, definition, options) {
    var converter = definition.converter || propertyConverters.get(definition.type);
    var arr = (array instanceof Array) ?
        array :
        (converter && converter.collapseArrayWithSingleItem() ?
            [array] :
            array);
    return arr.map(function (v) { return deserializeObject(v, definition, options); });
}
function deserializeObject(object, definition, options) {
    var primitive = definition.type === String || definition.type === Boolean || definition.type === Number;
    var value = object;
    var converter = definition.converter || propertyConverters.get(definition.type);
    if (converter) {
        return converter.deserialize(value);
    }
    if (!primitive) {
        var objDefinition = objectDefinitions.get(definition.type);
        if (objDefinition) {
            return deserialize(value, definition.type, options);
        }
    }
    return value;
}
