import * as util from "util";
import { propertyConverters } from "./../converters/converter";
import { objectDefinitions, getTypedInheritanceChain } from "../classes/object-definition";
export function serialize(value, type, options) {
    if (options === void 0) { options = { keyToPreserveUnknownJSON: undefined }; }
    if (value.constructor === Array) {
        return value.map(function (o) { return serializeRootObject(o, type, options); });
    }
    return serializeRootObject(value, type, options);
}
function serializeRootObject(object, type, options) {
    if (type === void 0) { type = Object.getPrototypeOf(object).constructor; }
    var inheritanceChain = getTypedInheritanceChain(type);
    if (inheritanceChain.length === 0) {
        return object;
    }
    var definitions = inheritanceChain
        .map(function (t) { return objectDefinitions.get(t); })
        .filter(function (t) { return !!t; }); // Typescript doesn't yet support the undefined filter
    var output = {};
    definitions.forEach(function (d) {
        d.properties.forEach(function (p, key) {
            if (!p.type) {
                throw new Error("Cannot serialize property '" + key + "' without type!");
            }
            var value = object[key];
            if (value == undefined || p.writeonly) {
                return;
            }
            if (p.set) {
                output[p.serializedName] = serializeArray(Array.from(value || []), p, options);
                return;
            }
            if (p.array) {
                output[p.serializedName] = serializeArray(value, p, options);
                return;
            }
            output[p.serializedName] = serializeObject(value, p, options);
        });
    });
    if (options.keyToPreserveUnknownJSON) {
        var anchor = options.keyToPreserveUnknownJSON;
        if (object[anchor]) {
            var jsonProps = Object.keys(object[anchor]);
            var _loop_1 = function (jsonProp) {
                if (object[anchor].hasOwnProperty(jsonProp)) {
                    var property_1;
                    definitions.forEach(function (d) {
                        d.properties.forEach(function (p, key) {
                            if (!property_1 && jsonProp === p.serializedName) {
                                property_1 = p;
                                // break
                            }
                        });
                    });
                    if (!property_1) {
                        if (typeof output[jsonProp] !== "undefined") {
                            console.log("???!!! TAJSON keyToPreserveUnknownJSON already serialized?! " + anchor + "." + jsonProp);
                            // breakLength: 100  maxArrayLength: undefined
                            // tslint:disable-next-line: max-line-length
                            console.log(util.inspect(output[jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            if (output[jsonProp] !== object[anchor][jsonProp]) {
                                console.log("???!!! TAJSON keyToPreserveUnknownJSON already serialized DIFF?! " + anchor + "." + jsonProp);
                                // breakLength: 100  maxArrayLength: undefined
                                // tslint:disable-next-line: max-line-length
                                console.log(util.inspect(object[anchor][jsonProp], { showHidden: false, depth: 1000, colors: true, customInspect: false }));
                            }
                        }
                        // warning: reference copy, not deep clone!
                        output[jsonProp] = object[anchor][jsonProp];
                    }
                }
            };
            for (var _i = 0, jsonProps_1 = jsonProps; _i < jsonProps_1.length; _i++) {
                var jsonProp = jsonProps_1[_i];
                _loop_1(jsonProp);
            }
        }
    }
    return output;
}
function serializeArray(array, definition, options) {
    var arr = array.map(function (v) { return serializeObject(v, definition, options); });
    if (arr.length === 1) {
        var converter = definition.converter || propertyConverters.get(definition.type);
        if (converter && converter.collapseArrayWithSingleItem()) {
            return arr[0];
        }
    }
    return arr;
}
function serializeObject(object, definition, options) {
    var primitive = definition.type === String || definition.type === Boolean || definition.type === Number;
    var value = object;
    var converter = definition.converter || propertyConverters.get(definition.type);
    if (converter) {
        return converter.serialize(value);
    }
    if (!primitive) {
        var objDefinition = objectDefinitions.get(definition.type);
        if (objDefinition) {
            if (value instanceof definition.type) {
                return serialize(value, undefined, options);
            }
            return serialize(value, definition.type, options);
        }
    }
    return value;
}
